import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';
import { STTService } from '../services/stt/sttService';
import { TTSService } from '../services/tts/ttsService';
import { InterviewAgent } from '../services/interview/interviewAgent';

dotenv.config();

interface STTEventData {
  sessionId: string;
  text?: string;
  confidence?: number;
  error?: string;
}

interface ActiveSession {
  sessionId: string;
  socketId: string;
  createdAt: Date;
  techStack?: string;
  position?: string;
}

export class VoiceInterviewServer {
  private app: express.Application;
  private server: http.Server;
  private io: Server;
  private sttService: STTService;
  private ttsService: TTSService;
  private agent: InterviewAgent;
  private activeSessions: Map<string, ActiveSession>;
  private socketToSession: Map<string, string>; // socket.id -> sessionId

  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.activeSessions = new Map();
    this.socketToSession = new Map();
    
    // Initialize Socket.IO with proper CORS
    this.io = new Server(this.server, {
      cors: {
        origin: process.env.FRONTEND_URL || "http://localhost:3000",
        methods: ["GET", "POST"],
        credentials: true
      },
      transports: ['websocket', 'polling'],
      allowEIO3: true
    });

    // Initialize services
    this.sttService = new STTService();
    this.ttsService = new TTSService();
    this.agent = new InterviewAgent();
    
    this.setupMiddleware();
    this.setupRoutes();
    this.setupSocketHandlers();
    this.setupServiceEvents();

    // Ensure audio output directory exists
    this.ensureAudioDirectory();

    console.log('âœ… VoiceInterviewServer initialized with session isolation');
  }

  private ensureAudioDirectory(): void {
    const audioDir = path.join(process.cwd(), 'audio_output');
    if (!fs.existsSync(audioDir)) {
      fs.mkdirSync(audioDir, { recursive: true });
      console.log('ðŸ“ Created audio_output directory');
    }
  }

  private setupMiddleware(): void {
    this.app.use(cors({
      origin: process.env.FRONTEND_URL || "http://localhost:3000",
      credentials: true
    }));
    
    this.app.use(express.json());
    this.app.use(express.static('public'));
    this.app.use('/audio', express.static('audio_output'));
  }

  private setupRoutes(): void {
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        activeSessions: this.activeSessions.size,
        activeSTTSessions: this.sttService.getActiveSessionsCount(),
        activeSessionDetails: Array.from(this.activeSessions.values()).map(session => ({
          sessionId: session.sessionId,
          socketId: session.socketId,
          createdAt: session.createdAt,
          sttActive: this.sttService.isSessionActive(session.sessionId)
        }))
      });
    });

    this.app.get('/session/:sessionId', (req, res) => {
      const { sessionId } = req.params;
      const session = this.activeSessions.get(sessionId);
      
      if (!session) {
        return res.status(404).json({ error: 'Session not found' });
      }

      res.json({
        sessionId: session.sessionId,
        socketId: session.socketId,
        createdAt: session.createdAt,
        sttActive: this.sttService.isSessionActive(sessionId),
        sttInfo: this.sttService.getSessionInfo(sessionId)
      });
    });
  }

  private setupSocketHandlers(): void {
    this.io.on('connection', (socket) => {
      console.log(`ðŸ”Œ Client connected: ${socket.id}`);

      socket.on('startInterview', async (data) => {
        try {
          const sessionId = uuidv4().substring(0, 8);
          
          console.log(`ðŸŽ¯ Starting interview:`, {
            sessionId,
            socketId: socket.id,
            techStack: data.techStack,
            position: data.position
          });

          const session: ActiveSession = {
            sessionId,
            socketId: socket.id,
            createdAt: new Date(),
            techStack: data.techStack,
            position: data.position
          };
          
          this.activeSessions.set(sessionId, session);
          this.socketToSession.set(socket.id, sessionId);
          socket.join(sessionId);
          
          await this.sttService.startSession(sessionId, socket.id);
          const question = this.generateInterviewQuestion(data.techStack, data.position);

          this.io.to(sessionId).emit('interviewStarted', {
            sessionId,
            question: { questionText: question }
          });

          console.log(`âœ… Interview started successfully for session: ${sessionId}`);
          
          await this.generateTTSAudio(sessionId, question);

        } catch (error) {
          console.error(`âŒ Error starting interview:`, error);
          socket.emit('error', 'Failed to start interview');
        }
      });

      socket.on('audioChunk', (data) => {
        const { sessionId, audioData } = data;
        
        if (!sessionId) {
          console.error('âŒ No sessionId provided with audio chunk');
          return;
        }

        const session = this.activeSessions.get(sessionId);
        if (!session) {
          console.error(`âŒ Invalid session for audio chunk: ${sessionId}`);
          return;
        }

        if (session.socketId !== socket.id) {
          console.error(`âŒ Socket ${socket.id} doesn't own session ${sessionId}`);
          return;
        }

        try {
          const buffer = Buffer.from(audioData);
          this.sttService.processAudioChunk(sessionId, buffer);
        } catch (error) {
          console.error(`âŒ Error processing audio chunk for ${sessionId}:`, error);
        }
      });

      socket.on('finalizeAudio', (data) => {
        const { sessionId } = data;
        if (sessionId && this.activeSessions.has(sessionId)) {
          this.sttService.finishSession(sessionId);
        }
      });

      socket.on('endInterview', (data) => {
        const { sessionId } = data;
        if (sessionId) {
          this.cleanupSession(sessionId);
          this.io.to(sessionId).emit('interviewComplete', { sessionId });
        }
      });

      socket.on('disconnect', (reason) => {
        console.log(`ðŸ”Œ Client disconnected: ${socket.id}, Reason: ${reason}`);
        const sessionId = this.socketToSession.get(socket.id);
        if (sessionId) {
          this.cleanupSession(sessionId);
        }
        this.sttService.cleanupBySocketId(socket.id);
      });

      socket.on('error', (error) => {
        console.error(`âŒ Socket error for ${socket.id}:`, error);
      });
    });
  }

  private setupServiceEvents(): void {
    // STT Handlers
    this.sttService.on('connected', (data: STTEventData) => {
      const { sessionId } = data;
      const session = this.activeSessions.get(sessionId);

      if (session) {
        this.io.to(sessionId).emit('sttConnected', { sessionId });
        console.log(`ðŸŽ¤ STT connected for session: ${sessionId}`);
      }
    });

    this.sttService.on('interimTranscript', (data: STTEventData) => {
      const { sessionId, text, confidence } = data;
      const session = this.activeSessions.get(sessionId);

      if (session && text?.trim()) {
        this.io.to(sessionId).emit('interimTranscript', {
          sessionId,
          text,
          confidence,
          timestamp: new Date()
        });
      }
    });

    this.sttService.on('transcript', (data: STTEventData) => {
      const { sessionId, text, confidence } = data;
      const session = this.activeSessions.get(sessionId);

      if (session && text?.trim()) {
        this.io.to(sessionId).emit('transcript', {
          sessionId,
          text,
          confidence,
          isFinal: true,
          timestamp: new Date()
        });
        
        // Process answer through interview agent
        this.agent.processAnswer(sessionId, text);
        console.log(`ðŸ“ Final transcript for ${sessionId}:`, text);
      }
    });

    this.sttService.on('error', (data: STTEventData) => {
      const { sessionId, error } = data;
      const session = this.activeSessions.get(sessionId);
      
      if (session) {
        this.io.to(sessionId).emit('sttError', { sessionId, error });
        console.error(`âŒ STT error for session ${sessionId}:`, error);
      }
    });

    this.sttService.on('disconnected', (data: STTEventData) => {
      const { sessionId } = data;
      console.log(`ðŸŽ¤ STT disconnected for session: ${sessionId}`);
    });

    // Interview Agent Handlers
    this.agent.on('nextQuestion', ({sessionId, question}) => {
      this.ttsService.speak(question, sessionId);
      this.io.to(sessionId).emit('nextQuestion', {sessionId, question});
    });

    // TTS Handlers
    this.ttsService.on('audioGenerated', (data) => {
      this.io.to(data.sessionId).emit('audioGenerated', data);
    });

    this.ttsService.on('audioFinished', (data) => {
      this.io.to(data.sessionId).emit('audioFinished', {
        sessionId: data.sessionId,
        audioUrl: data.audioUrl
      });
    });

    this.ttsService.on('error', ({ sessionId, error }) => {
      this.io.to(sessionId).emit('error', { sessionId, error });
    });
  }

  private generateInterviewQuestion(techStack: string, position: string): string {
    const greeting = `Hello! I'm Prep Piper, your AI interviewer for today's ${position} interview focusing on ${techStack}.`;
    this.agent.startInterview(techStack, position);
    return greeting;
  }

  private async generateTTSAudio(sessionId: string, text: string): Promise<void> {
    try {
      console.log(`ðŸ”Š Generating TTS audio for session: ${sessionId}`);
      await this.ttsService.speak(text, sessionId);
    } catch (error) {
      console.error(`âŒ Error generating TTS for session ${sessionId}:`, error);
      this.io.to(sessionId).emit('error', 'Failed to generate audio');
    }
  }

  private processTranscriptAndRespond(sessionId: string, transcript: string, session: ActiveSession): void {
    console.log(`ðŸ¤– Processing transcript for ${sessionId}: ${transcript}`);
    // The agent will handle this via event handlers we set up in setupServiceEvents
    this.agent.processAnswer(sessionId, transcript);
  }

  private cleanupSession(sessionId: string): void {
    console.log(`ðŸ§¹ Cleaning up session: ${sessionId}`);
    
    const session = this.activeSessions.get(sessionId);
    if (session) {
      this.socketToSession.delete(session.socketId);
    }
    
    this.activeSessions.delete(sessionId);
    this.sttService.finishSession(sessionId);
    this.io.socketsLeave(sessionId);
  }

  start(port: number): void {
    this.server.listen(port, () => {
      console.log(`ðŸš€ Server listening on http://localhost:${port}`);
      console.log(`ðŸŽ¤ STT Service ready with session isolation`);
      console.log(`ðŸ”Š TTS Service ready`);
      console.log(`ðŸ”Œ WebSocket server ready`);
      console.log(`ðŸ“Š Active sessions: ${this.activeSessions.size}`);
    });
  }

  async stop(): Promise<void> {
    console.log('ðŸ›‘ Shutting down server...');
    
    for (const sessionId of this.activeSessions.keys()) {
      this.cleanupSession(sessionId);
    }
    
    await this.sttService.cleanup();
    
    this.server.close(() => {
      console.log('âœ… Server stopped');
    });
  }
}
